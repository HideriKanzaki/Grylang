#include <string>
#include <sstream>
#include <algorithm>
#include <functional>
#include <gryltools/stackreader.hpp>
#include <gryltools/stringtools.hpp>
#include <gryltools/printtools.hpp>
#include "gbnf.hpp"
extern "C" {
    #include <gryltools/hlog.h>
}

namespace gbnf{

/*===========================================================//
 * C++ Header file generator.
 * - Works by taking a GbnfData variable, and outputting it's construction
 *   code in C++ format.
 */   
class GbnfCodeGenerator : public CodeGenerator_impl
{
private:
    // Core:
    std::ostream& output;
    std::string includeGuard;

    // Helper Methods
    void properizeVarName( std::string& vname );
    void makeIncludeGuard( const std::string& fName );

    void outputTagTable( const GbnfData& data );
    void outputGrammarTable( const GbnfData& data );
    static void outputGrammarToken( std::ostream& outp, const GrammarToken& tok, 
                             const gtools::PrintTools::ListOutputParams& ps );

public:
    /*! Constructor. Just makes sure all necessary data is set checked.
     */  
    GbnfCodeGenerator( std::ostream& outp, const std::string& fName )
        : output( outp )
    { 
        makeIncludeGuard( fName ); 
    }

    void outputStart();
    void outputEnd();
    void generate( const GbnfData& gb, const std::string& vn ); 
};

/*! Properized a name - removes whitespaces and other invalids.
 */ 
void GbnfCodeGenerator::properizeVarName( std::string& vn ){
    // First char must be letter.
    while( !vn.empty() && !(std::isalpha( vn[0] ) || vn[0]=='_') )
        vn.erase(0, 1);

    if(vn.empty())
        vn.assign("yourGbnfData");
    else{
        for( auto &a : vn ){
            // Replace all invalid characters with '_'.
            if( !std::isalnum( a ) && a != '_' )
                a = '_';
        }
    } 
}
   
/*! Sets the proper variable names and other string properties.
 */ 
void GbnfCodeGenerator::makeIncludeGuard( const std::string& fName ){
    std::string vn = fName;
    properizeVarName( vn );

    includeGuard = std::move( vn );

    std::transform( includeGuard.begin(), includeGuard.end(), includeGuard.begin(), ::toupper);
    includeGuard.append("_HPP_INCLUDED");

    //output << "VarName: "<< vn <<", incGuard: "<<includeGuard<<"\n";
}

void GbnfCodeGenerator::outputStart(){
    output << "\n#ifndef "<< includeGuard <<"\n#define "<< includeGuard <<"\n\n";
    output << "/* File automatically generated by GBNFCodeGen Tool.\n";
    output << " * Edit at your own risk.\n */\n\n";
    output << "#include <gbnf.hpp>\n\nusing namespace gbnf;\n\n";
}

void GbnfCodeGenerator::outputEnd(){
    output<<"\n#endif // "<< includeGuard <<"\n\n";
}

/*! Actually generates the code and outputs it.
 */ 
void GbnfCodeGenerator::generate( const GbnfData& data, const std::string& vn ){
    std::string variableName = vn;
    properizeVarName( variableName );

    output << "\nconst GbnfData "<< variableName<< "= GbnfData( "<< data.flags <<" , \n";
    
    // Output TagTbl constructor
    outputTagTable( data );

    output<<" , \n";

    // Output GrammarTbl constructor
    outputGrammarTable( data );

    output<<"\n); \n\n";
}

void GbnfCodeGenerator::outputTagTable( const GbnfData& data ){
    gtools::PrintTools::outputInitializerList( this->output, 
        data.tagTable.begin(), data.tagTable.end(), 
        []( std::ostream& outp, const NonTerminal& a, const auto& ps ){
            outp << "NonTerminal( "<< a.ID <<" , ";
            if( !a.data.empty() ){
                std::string res = a.data;
                gtools::StringTools::escapeSpecials( res, true );
                outp << "\"" << res <<"\"";
            }
            else
                outp<< "\"\"";
            outp<<" )";
        } 
    );
}

void GbnfCodeGenerator::outputGrammarTable( const GbnfData& data ){
    using namespace gtools::PrintTools;
    outputInitializerList( this->output, data.grammarTable.begin(), data.grammarTable.end(), 
        []( std::ostream& outp, const GrammarRule& a, const ListOutputParams& ps ){
            outp << "GrammarRule( "<< a.ID <<" , ";

            ListOutputParams ps2 = ps;
            ps2.tabLeaderSize += 4;

            // Now output the options (tokens), using the specific recursive function.
            outputInitializerList( outp, a.options.begin(), a.options.end(),
                                   outputGrammarToken, ps2 );
            outp<<" )";
        } 
    );            
}

void GbnfCodeGenerator::outputGrammarToken( std::ostream& outp, const GrammarToken& tok,
                                  const gtools::PrintTools::ListOutputParams& ps ) {
    using namespace gtools::PrintTools;

    std::string res = tok.data;
    gtools::StringTools::escapeSpecials( res, true );

    outp << "GrammarToken( "<< GrammarToken::getTypeString( tok.type, true );
    outp << ", "<< tok.id <<", \""<< res <<"\", ";

    ListOutputParams ps2 = ps;
    ps2.tabLeaderSize += 4;

    // Now output the child options (tokens), using this current function.
    outputInitializerList( outp, tok.children.begin(), tok.children.end(),
                           outputGrammarToken, ps2 );
    outp<<" )";
}


//==========================================================//
//class CodeGenerator_impl;

/*! Constructor. Just makes sure all necessary data is set checked.
 */  
CodeGenerator::CodeGenerator( std::ostream& outp, const std::string& filename )
    : impl( new GbnfCodeGenerator( outp, filename ) )
{}

void CodeGenerator::outputStart(){
    impl->outputStart();
}

void CodeGenerator::outputEnd(){
    impl->outputEnd();
}

void CodeGenerator::generateConstructionCode( const GbnfData& gbData, 
                            const std::string& varName, int verbosity ){
    impl->generate( gbData, varName );
}

/*! GBNF TOOLS.
 *  Generates a C++ header file from GBNF data passed, and outputs to a stream.
 */ 
void generateCode( const GbnfData& data, std::ostream& output, 
                   const char* variableName, int verbosity ){
    GbnfCodeGenerator gen( output, std::string( variableName ) );
    gen.outputStart();
    gen.generate( data, std::string( variableName ) );
    gen.outputEnd();
}

} // Namespace gbnf end.

//end.
