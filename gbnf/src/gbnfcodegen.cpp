#include <string>
#include <sstream>
#include <algorithm>
#include <functional>
#include <gryltools/stackreader.hpp>
#include <gryltools/stringtools.hpp>
#include <gryltools/printtools.hpp>
#include "gbnf.hpp"
extern "C" {
    #include <gryltools/hlog.h>
}

namespace gbnf{

/*===========================================================//
 * C++ Header file generator.
 * - Works by taking a GbnfData variable, and outputting it's construction
 *   code in C++ format.
 */   
class GbnfCodeGenerator
{
private:
    // Core:
    std::ostream& output;
    const GbnfData& data;

    std::string variableName;
    std::string includeGuard;

    // Helper Methods
    void makeStringProperties( const std::string& varName ); 
    void outputTagTable();
    void outputGrammarTable();
    static void outputGrammarToken( std::ostream& outp, const GrammarToken& tok, 
                             const gtools::PrintTools::ListOutputParams& ps );

public:
    /*! Constructor. Just makes sure all necessary data is set checked.
     */  
    GbnfCodeGenerator(const GbnfData& gbData, std::ostream& outp, const std::string& varName)
        : output( outp ), data( gbData )
    { 
        makeStringProperties( varName ); 
    }
    
    void generate();
};
   
/*! Sets the proper variable names and other string properties.
 */ 
void GbnfCodeGenerator::makeStringProperties( const std::string& varNameStart ){
    variableName = varNameStart;
    std::string& vn = variableName;

    // First char must be letter.
    while( !vn.empty() && !(std::isalpha( vn[0] ) || vn[0]=='_') )
        vn.erase(0, 1);

    if(vn.empty())
        vn.assign("yourGbnfData");
    else{
        for( auto &a : vn ){
            // Replace all invalid characters with '_'.
            if( !std::isalnum( a ) && a != '_' )
                a = '_';
        }
    }

    // Variable name is done. Now generate include guard.
    includeGuard = variableName;
    std::transform( includeGuard.begin(), includeGuard.end(), includeGuard.begin(), ::toupper);
    includeGuard.append("_HPP_INCLUDED");

    //output << "VarName: "<<variableName<<", incGuard: "<<includeGuard<<"\n";
}


/*! Actually generates the code and outputs it.
 */ 
void GbnfCodeGenerator::generate(){
    output << "\n#ifndef "<< includeGuard <<"\n#define "<< includeGuard <<"\n\n";
    output << "/* File automatically generated by GBNFCodeGen Tool.\n";
    output << " * Edit at your own risk.\n */\n\n";
    output << "#include <gbnf.hpp>\n\nusing namespace gbnf;\n\n";

    output << "const GbnfData "<< variableName<< "= GbnfData( "<< data.flags <<" , \n";
    
    // Output TagTbl constructor
    outputTagTable();

    output<<" , \n";

    // Output GrammarTbl constructor
    outputGrammarTable();

    output<<"\n); \n\n";
    output<<"#endif // "<< includeGuard <<"\n";

    /*GbnfData nuda( 1, { NonTerminal(1, "kaka"), NonTerminal(2, "baba"), }, {} ); 
    output<< nuda;

    output<<"\nTesting gtools::StringTools...\n";
    std::string nn ("\0\tabc\x01\nzaza\0", 12);
    
    gtools::StringTools::escapeSpecials( nn, true );

    output<<"Result: \""<< nn <<"\"\n";
    */
}

void GbnfCodeGenerator::outputTagTable(){
    gtools::PrintTools::outputInitializerList( this->output, 
        data.tagTable.begin(), data.tagTable.end(), 
        []( std::ostream& outp, const NonTerminal& a, const auto& ps ){
            outp << "NonTerminal( "<< a.ID <<" , ";
            if( !a.data.empty() ){
                std::string res = a.data;
                gtools::StringTools::escapeSpecials( res, true );
                outp << "\"" << res <<"\"";
            }
            else
                outp<< "\"\"";
            outp<<" )";
        } 
    );
}

void GbnfCodeGenerator::outputGrammarTable(){
    using namespace gtools::PrintTools;
    outputInitializerList( this->output, data.grammarTable.begin(), data.grammarTable.end(), 
        []( std::ostream& outp, const GrammarRule& a, const ListOutputParams& ps ){
            outp << "GrammarRule( "<< a.ID <<" , ";

            ListOutputParams ps2 = ps;
            ps2.tabLeaderSize += 4;
            ps2.bracesInNewLines = true;
            ps2.oneLineElements = 4;

            // Now output the options (tokens), using the specific recursive function.
            outputInitializerList( outp, a.options.begin(), a.options.end(),
                                   outputGrammarToken, ps2 );
            outp<<" )";
        } 
    );            
}

void GbnfCodeGenerator::outputGrammarToken( std::ostream& outp, const GrammarToken& tok,
                                  const gtools::PrintTools::ListOutputParams& ps ) {
    using namespace gtools::PrintTools;

    std::string res = tok.data;
    gtools::StringTools::escapeSpecials( res, true );

    outp << "GrammarToken( "<< GrammarToken::getTypeString( tok.type );
    outp <<", "<< tok.id <<", \""<< res <<"\", ";

    ListOutputParams ps2 = ps;
    ps2.tabLeaderSize += 4;

    // Now output the child options (tokens), using this current function.
    outputInitializerList( outp, tok.children.begin(), tok.children.end(),
                           outputGrammarToken, ps2 );
    outp<<" )";

}



//==========================================================//

/*! GBNF TOOLS.
 *  Generates a C++ header file from GBNF data passed, and outputs to a stream.
 */ 
void generateCode(const GbnfData& data, std::ostream& output, const char* variableName){
    GbnfCodeGenerator gen( data, output, std::string( variableName ) );
    gen.generate();
}

} // Namespace gbnf end.

//end.
